-buf_read()
--note pour la partie : 2.b. Check if buffer is empty -> Blocking mode: sleep until data is available
┌─────────────────────────────────────────────────────────┐
│  ÉTAT INITIAL (on entre dans le if)                     │
├─────────────────────────────────────────────────────────┤
│  Buffer.BufEmpty = 1  (TRUE)                            │
│  Donc : !Buffer.BufEmpty = 0  (FALSE)                   │
│                                                          │
│  → La condition est FAUSSE au départ                    │
│  → Le processus VA DORMIR obligatoirement               │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│  ÉTAPE 1 : Évaluation initiale                          │
├─────────────────────────────────────────────────────────┤
│  wait_event_interruptible(dev->OutQueue, !Buffer.BufEmpty)
│                                                          │
│  Vérifie : !Buffer.BufEmpty = !1 = 0 (FALSE)           │
│                                                          │
│  Condition FALSE → Le processus DOIT dormir             │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│  ÉTAPE 2 : DORMIR                                       │
├─────────────────────────────────────────────────────────┤
│  1. Ajouter le processus à dev->OutQueue                │
│  2. État → TASK_INTERRUPTIBLE                           │
│  3. schedule() - céder le CPU                           │
│                                                          │
│  💤 Le processus dort...                                │
└─────────────────────────────────────────────────────────┘
                         ↓
                    ⏳ ATTENTE ⏳
                         ↓
┌─────────────────────────────────────────────────────────┐
│  RÉVEIL PAR UN ÉCRIVAIN                                 │
├─────────────────────────────────────────────────────────┤
│  Dans buf_write() :                                     │
│    BufIn(&Buffer, &data);                               │
│    // Buffer.BufEmpty = 0 maintenant !                  │
│    wake_up_interruptible(&dev->OutQueue);               │
│                                                          │
│  → Tous les processus dans OutQueue sont réveillés      │
└─────────────────────────────────────────────────────────┘
                         ↓
┌─────────────────────────────────────────────────────────┐
│  ÉTAPE 3 : APRÈS LE RÉVEIL                              │
├─────────────────────────────────────────────────────────┤
│  wait_event_interruptible réévalue la condition :       │
│                                                          │
│  !Buffer.BufEmpty = !0 = 1 (TRUE) ✓                    │
│                                                          │
│  Condition VRAIE → Sortir de la boucle                  │
│  Retourner 0                                            │
└─────────────────────────────────────────────────────────┘
                         ↓
                    Continue...



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



-- note pour la partie :  2.c. Buffer has data - fill ReadBuf -> Determine how many items to read in this iteration
À ce stade du code :
-On a le sémaphore
-Le buffer n'est pas vide (il y a des données)
-On veut lire des données

Mais on doit répondre à : Combien de données lire MAINTENANT ?
Les contraintes
Il y a TROIS limites à respecter :
┌────────────────────────────────────────────────────┐
│ 1. Ce que l'utilisateur veut encore                │
│    → count - bytes_read                            │
├────────────────────────────────────────────────────┤
│ 2. La taille de notre buffer temporaire (ReadBuf)  │
│    → READWRITE_BUFSIZE * sizeof(unsigned short)    │
├────────────────────────────────────────────────────┤
│ 3. Ce qui est disponible dans le buffer circulaire │
│    → (géré dans la boucle for plus tard)           │
└────────────────────────────────────────────────────┘

- Calculer bytes_to_read :
bytes_to_read = min(count - bytes_read, 
                    (size_t)(READWRITE_BUFSIZE * sizeof(unsigned short)));
                    
Partie A : count - bytes_read = Ce qui reste à lire (bytes_read = ce qu'on a déjà lu)
Partie B : READWRITE_BUFSIZE * sizeof(unsigned short) = Taille maximale du buffer temporaire
La fonction min() : Prend le plus petit des deux

-Calculer items_to_read
int items_to_read = bytes_to_read / sizeof(unsigned short);
Convertir octets → nombre d'items (Notre buffer stocke des unsigned short : 2 octets chacun)
